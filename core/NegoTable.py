#######################################################
#
# NegoTable.py
# Python implementation of the Class NegoTable
# Generated by Enterprise Architect
# Created on:      26-����-2022 02:24:13 �.�
# Original author: Arash Ebrahimnezhad
#
#######################################################
from core.Offer import Offer
from core.TimeLine import TimeLine
from core.StateInfo import StateInfo


class NegoTable:

    def __init__(self, state_info: StateInfo, time_line: TimeLine, *party_ids):
        """
        In initializing of AbstractProtocol a data structure will be created
        in order to show offers_on_the_table. an example of this data structure was shown in the following:
        {party1:[offer1, offer2, ...], party2:[offer1, offer2, ...], ...}
        :param parties: tuple of party's names (string)
        :param state_info:
        """
        for party_id in party_ids:
            if not isinstance(party_id, str):
                raise TypeError('parties argument must be the tuple of string!')

        if not isinstance(state_info, StateInfo):
            raise TypeError('state_info argument must be instance of StateInfo!')
        if not isinstance(time_line, TimeLine):
            raise TypeError('time_line argument must be instance of TimeLine!')

        self.__party_ids = party_ids
        self.__state_info = state_info
        self.__time_line = time_line
        self.__offers_on_the_table = {}
        for party_id in party_ids:
            self.__offers_on_the_table[party_id] = []

    def get_state_info(self) -> StateInfo:
        return self.__state_info

    def get_offers_on_table(self):
        return self.__offers_on_the_table

    def get_party_offers_on_table(self, party_id):
        return self.__offers_on_the_table[party_id]

    def get_party_ids(self) -> tuple:
        return self.__party_ids

    def get_time(self) -> float:
        return self.__time_line.get_time()

    def get_time_line(self) -> TimeLine:
        return self.__time_line

    def add_offer(self, party_id: str, offer: Offer):
        if not isinstance(party_id, str):
            raise TypeError('party argument must be an instance of string')
        if not isinstance(offer, Offer):
            raise TypeError('offer argument must be an instance of Offer')
        self.__offers_on_the_table[party_id].append(offer)

    def is_table_empty(self) -> bool:
        """
        this method returns True if there is no
        offer on the table and vice versa
        :return: True|False
        """
        for party in self.__party_ids:
            if self.__offers_on_the_table[party]:
                return False
        return True

